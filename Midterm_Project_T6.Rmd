---
title: "Data Brew: Brewing Success with Starbucks Customer Insights"
subtitle: "TEAM 6 - Chekitha Swayampu, Hrushikesh Sai Seshagiri Chowdary Uppalapati, Swathi Murali Srinivasan, Vaishnavi Tamilvanan"
date: "2023-10-20"
output:
  prettydoc::html_pretty:
    theme: hpstr
    toc: true
  pdf_document:
    toc: yes
    toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, results='markup'}
# Importing and reading the Datasets 
df_cust_offer<-read.csv("data/transcript.csv")
# df_cust_offer <- df_cust_offer[, -1]
head(df_cust_offer)
print("The structure of Transcript:")
str(df_cust_offer)

df_offers<-read.csv("data/portfolio.csv")
df_offers<- df_offers[, -1]
head(df_offers)
print("The structure of Portfolio:")
str(df_offers)

df_cust<-read.csv("data/profile.csv")
df_cust<- df_cust[, -1]
head(df_cust)
print("The structure of Profile:")
str(df_cust)
```

```{r, results='markup'}
#Checking for the Missing values in each column of the dataframes
cust_offer_missing_values <- colSums(is.na(df_cust_offer))
print("Missing values in transcript:")
print(cust_offer_missing_values)


offers_missing_values <- colSums(is.na(df_offers))
print("Missing values in portfolio:")
print(offers_missing_values)


df_cust$gender[df_cust$gender == ""] <- NA #Filling empty spaces with NA values
cust_missing_values <- colSums(is.na(df_cust))
print("Missing values in profile:")
print(cust_missing_values)
```

```{r}
missing_gender <- df_cust[is.na(df_cust$gender), ]
missing_income <- df_cust[is.na(df_cust$income), ]
sum(missing_gender$id == missing_income$id)
```

```{r}
#Checking count of missing values if they are from the same observations
missing_gender_and_income <- sum(is.na(df_cust$gender) & is.na(df_cust$income))
print("Count of missing values in both gender and income:")
print(missing_gender_and_income)
```

```{r}
# Identify 'id' values to remove
id_to_remove <- missing_income$id

# Create a new dataframe without the rows where 'id' is in 'id_to_remove'
df_customer_no_na <- df_cust[!df_cust$id %in% id_to_remove, ]

# Reset the row indices
rownames(df_customer_no_na) <- NULL

# Display information about the resulting dataframe
str(df_customer_no_na)
#There are no NA values in df_customer_no_na
sum(is.na(df_customer_no_na))
```

```{r}
missing_gender_and_income_together <- df_cust[is.na(df_cust$gender) & is.na(df_cust$income), ]
head(missing_gender_and_income_together)
```

```{r}
#Checking the columns with numerical data 
cust_numcols <- names(df_customer_no_na)[sapply(df_customer_no_na, is.numeric)]
head(cust_numcols)
```

```{r}
#Converting became_member_on to datetime format
df_customer_no_na$became_member_on <- as.Date(as.character(df_customer_no_na$became_member_on), format = "%Y%m%d")
head(df_customer_no_na)

# Save checkpoint after data cleaning
customers <- data.frame(df_customer_no_na)
```

```{r}
#Drop the unnecessary first Column in transcript
# df_cust_offer <- df_cust_offer[, -1]
head(df_cust_offer)
```

```{r}
#check transcript data frame data types
df_cust_offer_dtypes <- sapply(df_cust_offer, class)
print(df_cust_offer_dtypes)
```

```{r}
library(dplyr)

# Convert time in hours to number of days
df_cust_offer <- df_cust_offer %>% 
  mutate(
    days_elapsed = time / 24,  # Add a new column for days
    hours_elapsed = time      # Rename time to hours_elapsed
  ) %>% 
  select(-time)  # Remove the original time column if needed
```

```{r}
#Rename columns 
colnames(df_cust_offer)[colnames(df_cust_offer) == "person"] <- "customer_id"
tail(df_cust_offer)
```

# **Data Transformation**

## Transform `df_offers`

Add an alias to each offer for easier recognition and referencing.

```{r}
# Load required library
library(dplyr)
# Sort df_offer by offer_type and difficulty
df_offers <- df_offers %>%
  arrange(offer_type, difficulty) %>%
  mutate(index = row_number()) %>%
  select(-index)

# Add the offer_alias column
df_offers$offer_alias <- LETTERS[1:nrow(df_offers)]
head(df_offers)
```

## Transform `df_cust_offer`

```{r}
# Extract the 'customer_id' and 'event' columns
df_cust_offer_subset <- df_cust_offer[, c("customer_id", "event","days_elapsed","hours_elapsed")]
 
# Split the 'value' column into 'value_key' and 'value_data'
df_cust_offer_subset$value_key <- sapply(strsplit(df_cust_offer$value, "[:,]") , "[[", 1)
df_cust_offer_subset$value_data <- sapply(strsplit(df_cust_offer$value, "[:,]") , "[[", 2)
 
# Remove any leading/trailing white spaces
df_cust_offer_subset$value_key <- trimws(df_cust_offer_subset$value_key)
df_cust_offer_subset$value_data <- trimws(df_cust_offer_subset$value_data)
 
# Remove unwanted characters, including brackets and spaces, from 'value_key' and 'value_data'
df_cust_offer_subset$value_key <- gsub("[{}',\";]", "", df_cust_offer_subset$value_key)
df_cust_offer_subset$value_data <- gsub("[{}',\";]", "", df_cust_offer_subset$value_data)
# Display the resulting data frame
head(df_cust_offer_subset)
```

```{r}
df_cust_offer<- df_cust_offer_subset
head(df_cust_offer)
```

## Dividing customers into age groups:

```{r}
# Define the age bins and labels
age_bins <- c(customers$age %>% min(), 26, 36, 46, 56, 66, 76, 86, customers$age %>% max())
age_labels <- c('18-25ys', '26-35ys', '36-45ys', '46-55ys', '56-65ys', '66-75ys', '76-85ys', '> 86ys')

# Create the age_group column
customers$age_group <- cut(customers$age, breaks = age_bins, labels = age_labels, include.lowest = TRUE)
```

## MERGING ALL THE CSV FILES

Merging the datasets based on common columns like customer_id,id and value_data

```{r}
# Merge df_offers and df_cust_offer on the common column 'id'
merged_df <- left_join(customers, df_cust_offer,by = c('id' = 'customer_id'))
head(merged_df)
final_merged_df <- full_join(merged_df, df_offers, by = c('value_data' = 'id'))
head(final_merged_df)
```

```{r}
na_counts <- colSums(is.na(final_merged_df))
print(na_counts)
final<-na.omit(final_merged_df)
head(final)
```

## Categorical and Numerical variables of final df

```{r}
#checking numerical cols of final df
numerical_cols <- sapply(final, is.numeric)
numerical_colnames <- names(final)[numerical_cols]

categorical_colnames <- names(final)[!numerical_cols]

max_length <- max(length(numerical_colnames), length(categorical_colnames))

numerical_colnames <- c(numerical_colnames, rep(NA, max_length - length(numerical_colnames)))
categorical_colnames <- c(categorical_colnames, rep(NA, max_length - length(categorical_colnames)))
var_df <- data.frame(Numeric = numerical_colnames, Categorical = categorical_colnames)

print(head(var_df))
```

# **EDA and SMART questions**

## **EDA on transcripts data:**

```{r}
library(ezids)
# Get value counts for the 'event' column
event_value_counts <- table(df_cust_offer$event)

# Print the value counts
xkabledply(event_value_counts)

```

```{r}
# EDA on event occurences
# Load the required libraries
library(ggplot2)
library(plotly)

# Create a data frame from the event counts
event_counts_df <- data.frame(event = names(event_value_counts), count = as.numeric(event_value_counts))

# Define a vector of colors for  four events
event_colors <- c("Coral", "Cyan", "Magenta", "Turquoise")

# Create a ggplot2 bar chart 
p <- ggplot(event_counts_df, aes(x = event, y = count, fill = event)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = event_colors) +
  labs(title = "Event Distribution", x = "Event", y = "Count") +
  theme_minimal() +
  scale_y_continuous(breaks = seq(0, max(event_counts_df$count), by = 20000)) +
  coord_flip() +
  theme(panel.border = element_rect(color = "black", fill = NA),
        panel.grid = element_blank(),
        axis.text.x = element_text(face = "bold", color = "black"),
        axis.text.y = element_text(face = "bold", color = "black")) 

# Make the ggplot2 chart interactive using plotly
interactive_plot <- ggplotly(p)

# Display the interactive plot
interactive_plot
```

**OBSERVATION:**

1.  The dataset contains 138,953 transactions, which is more than four times the number of completed offers. This suggests that many customers made multiple purchases without the influence of an offer. This indicates a high level of customer loyalty, which is expected, given that Starbucks primarily offers fast-moving consumer goods such as coffee and food.

2.  During the campaign month, around 76,277 offers were sent to customers, and a remarkable 76% of these offers were viewed by customers. This high view rate reflects active customer engagement and suggests that the promotional slogans and design were effective in attracting customer attention.

3.  And 33,579 offers were completed, accounting for 58% of the viewed offers and 44% of all the offers sent. This relatively high offer completion rate is indicative of strong customer loyalty, likely indicating a substantial number of regular customers who regularly participate in Starbucks' promotions.

```{r}
#Print min and max of days elapsed
min_days_elapsed <- min(df_cust_offer$days_elapsed)
max_days_elapsed <- max(df_cust_offer$days_elapsed)

cat("Minimum days_elapsed:", min_days_elapsed, "\n")
cat("Maximum days_elapsed:", max_days_elapsed, "\n")


#Print min and max of hours elapsed
min_hours_elapsed <- min(df_cust_offer$hours_elapsed)
max_hours_elapsed <- max(df_cust_offer$hours_elapsed)

cat("Minimum hours_elapsed:", min_hours_elapsed, "\n")
cat("Maximum hourss_elapsed:", max_hours_elapsed, "\n")

```

```{r}
# Events occurence over time histogram
library(ggplot2)
library(plotly)

# Create the histogram
hist_plot <- ggplot(df_cust_offer, aes(x = days_elapsed)) +
  geom_histogram(
    bins = 30,
    fill = "orange",
    color = "lightblue",
    alpha = 0.7,
    linewidth = 0.5
  ) +
  labs(
    x = "Days",
    y = "Events Count",
    title = "Events Occurrence over Time"
  ) +
  theme_minimal() +
  theme(
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 14),
    plot.title = element_text(size = 16),
    panel.border = element_rect(color = "black", fill = NA, linewidth = 0.5),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )

# Create an interactive plot
interactive_plot <- ggplotly(hist_plot, tooltip = "count") %>%
  highlight_key(~count)

# Display the interactive plot
interactive_plot

```

**OBSERVATION:** The above plot reveals six distinct peaks of events during the campaign, primarily associated with the reception of offers, followed by subsequent events like offer views, completions, and purchases.

### Event Occurrences Across Time - A Detailed Analysis

```{r}
# Libraries
library(dplyr)

# Subset the data for each event type and count occurrences per hour
viewed_hourly <- df_cust_offer %>%
  filter(event == 'offer viewed') %>%
  group_by(hours_elapsed) %>%
  summarize(count = n()) %>%
  arrange(hours_elapsed)

completed_hourly <- df_cust_offer %>%
  filter(event == 'offer completed') %>%
  group_by(hours_elapsed) %>%
  summarize(count = n()) %>%
  arrange(hours_elapsed)

transaction_hourly <- df_cust_offer %>%
  filter(event == 'transaction') %>%
  group_by(hours_elapsed) %>%
  summarize(count = n()) %>%
  arrange(hours_elapsed)

# Print the number of events for each type
cat("Number of 'offer viewed' events:", nrow(viewed_hourly), "\n")
cat("Number of 'offer completed' events:", nrow(completed_hourly), "\n")
cat("Number of 'transaction' events:", nrow(transaction_hourly), "\n")

```

```{r}

# Compare index values between viewed_hourly and completed_hourly
matches_viewed_completed <- sum(viewed_hourly$hours_elapsed %in% completed_hourly$hours_elapsed)

# Compare index values between completed_hourly and transaction_hourly
matches_completed_transaction <- sum(completed_hourly$hours_elapsed %in% transaction_hourly$hours_elapsed)

# Print the results
cat("Number of matches between 'viewed_hourly' and 'completed_hourly':", matches_viewed_completed, "\n")
cat("Number of matches between 'completed_hourly' and 'transaction_hourly':", matches_completed_transaction, "\n")


```

**OBSERVATION**: The indices of all three Series are the same, signifying the hours elapsed since the campaign began. Now we can conveniently create plots to illustrate how events are distributed over time.

```{r}

# Load the required libraries
library(dplyr)

# Filter and count events for each day
received_hourly <- df_cust_offer %>%
  filter(event == 'offer received') %>%
  group_by(hours_elapsed) %>%
  summarize(count = n()) %>%
  arrange(hours_elapsed)

viewed_hourly <- df_cust_offer %>%
  filter(event == 'offer viewed') %>%
  group_by(hours_elapsed) %>%
  summarize(count = n()) %>%
  arrange(hours_elapsed)

completed_hourly <- df_cust_offer %>%
  filter(event == 'offer completed') %>%
  group_by(hours_elapsed) %>%
  summarize(count = n()) %>%
  arrange(hours_elapsed)

transaction_hourly <- df_cust_offer %>%
  filter(event == 'transaction') %>%
  group_by(hours_elapsed) %>%
  summarize(count = n()) %>%
  arrange(hours_elapsed)



```

```{r}
# Load the required libraries
library(dplyr)

# Filter and count events for each day
received_daily <- df_cust_offer %>%
  filter(event == 'offer received') %>%
  group_by(days_elapsed) %>%
  summarize(count = n()) %>%
  arrange(days_elapsed)

viewed_daily <- df_cust_offer %>%
  filter(event == 'offer viewed') %>%
  group_by(days_elapsed) %>%
  summarize(count = n()) %>%
  arrange(days_elapsed)

completed_daily <- df_cust_offer %>%
  filter(event == 'offer completed') %>%
  group_by(days_elapsed) %>%
  summarize(count = n()) %>%
  arrange(days_elapsed)

transaction_daily <- df_cust_offer %>%
  filter(event == 'transaction') %>%
  group_by(days_elapsed) %>%
  summarize(count = n()) %>%
  arrange(days_elapsed)

```

```{r}

library(ggplot2)
library(gridExtra)

# Combine the data into one data frame for Days
combined_data_days <- data.frame(
  days_elapsed = received_daily$days_elapsed,
  received = received_daily$count,
  viewed = viewed_daily$count,
  completed = completed_daily$count
)

# Create the grouped bar plot for Days
p_days <- ggplot(combined_data_days, aes(x = days_elapsed)) +
  geom_bar(aes(y = received, fill = "Received"), stat = "identity", position = "dodge") +
  geom_bar(aes(y = viewed, fill = "Viewed"), stat = "identity", position = "dodge") +
  geom_bar(aes(y = completed, fill = "Completed"), stat = "identity", position = "dodge") +
  labs(title = "Event Frequency Distribution Day",
       x = "Days Elapsed", y = "Count") +
  scale_fill_manual(values = c("Received" = "skyblue", "Viewed" = "lightgreen", "Completed" = "orange")) +
  theme(legend.title = element_blank()) +
  xlim(0, 30)

# Combine the data into one data frame for Hours
combined_data_hours <- data.frame(
  hours_elapsed = received_hourly$hours_elapsed,
  received = received_hourly$count,
  viewed = viewed_hourly$count,
  completed = completed_hourly$count
)

# Create the grouped bar plot for Hours
p_hours <- ggplot(combined_data_hours, aes(x = hours_elapsed)) +
  geom_bar(aes(y = received, fill = "Received"), stat = "identity", position = "dodge") +
  geom_bar(aes(y = viewed, fill = "Viewed"), stat = "identity", position = "dodge") +
  geom_bar(aes(y = completed, fill = "Completed"), stat = "identity", position = "dodge") +
  labs(title = "Event Frequency Distribution Hour",
       x = "Hours Elapsed", y = "Count") +
  scale_fill_manual(values = c("Received" = "pink", "Viewed" = "lightblue", "Completed" = "violet")) +
  theme(legend.title = element_blank()) +
  xlim(0, 720)

# Arrange the plots side by side
grid.arrange(p_days, p_hours, ncol = 2)
```

**OBSERVATION:**

The stacked plot clearly illustrates a robust correlation between individuals viewing offers and subsequently using them. In most cases, when a person viewed an offer, they promptly took action, often within a few hours of seeing it. This pattern remained consistent when we examined the data on a daily basis, indicating that a significant number of customers not only engaged with the offer but also completed the offer on the very same day they encountered it.

### Q1: How do different promotional events (received, viewed, completed) affect customer retention and repeat business with Starbucks over time?

```{r}
# Load necessary libraries
library(dplyr)
library(ggplot2)

# Step 2: Calculate retention rate over time
retention_data <- df_cust_offer %>%
  group_by(customer_id, days_elapsed) %>%
  summarize(
    received = sum(event == "offer received"),
    viewed = sum(event == "offer viewed"),
    completed = sum(event == "offer completed")
  ) %>%
  ungroup() %>%
  group_by(days_elapsed) %>%
  summarize(
    retention_rate = sum(completed) / sum(received),
    repeat_business_rate = sum(completed > 1) / sum(received)
  )

# Custom color palette
my_colors <- c("#0072B2", "#D55E00")  # Blue and Orange

# Create curve charts for retention rate and repeat business rate
curve_chart_retention <- ggplot(retention_data, aes(x = days_elapsed, y = retention_rate)) +
  geom_smooth(method = "loess", se = FALSE, color = my_colors[1]) +
  labs(
    title = "Retention Rate Over Time",
    x = "Days from Start",
    y = "Retention Rate"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "white"),  # Dark gray background
    plot.margin = margin(15, 15, 15, 15),  # Add margin around the plot
  ) +
  xlim(1, 30)  # Set x-axis limits from 1 to 30

curve_chart_repeat_business <- ggplot(retention_data, aes(x = days_elapsed, y = repeat_business_rate)) +
  geom_smooth(method = "loess", se = FALSE, color = my_colors[2]) +
  labs(
    title = "Repeat Business Rate Over Time",
    x = "Days from Start",
    y = "Repeat Business Rate"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "white"),  # Dark gray background
    plot.margin = margin(15, 15, 15, 15),  # Add margin around the plot
  ) +
  xlim(1, 30)  # Set x-axis limits from 1 to 30

# Print the curve charts
print(curve_chart_retention)
print(curve_chart_repeat_business)
```

**ANSWER TO SMART QUESTION:**

The initial graph reveals a consistent upward trend in customer retention rates over time among those who have used the offer only once. This trend signifies a positive indicator, suggesting that customers are not only enjoying the offers they receive but also showing potential for becoming repeat customers. This group may represent customers who are initially enticed by the offer and, as their experience with Starbucks improves, are more likely to return for future purchases.

The second graph depicts a similar positive trend in customer retention rates over time, but this time among customers who have made multiple purchases using the offer. This is particularly encouraging for Starbucks, as it demonstrates a loyal customer base that consistently appreciates and benefits from the offers. It also indicates a level of trust and satisfaction among these customers, making them valuable assets to the business.

However, it's important to note that this exploratory data analysis (EDA) focuses solely on the duration of the campaign. To maximize long-term customer retention, Starbucks should consider tailoring their offers to specifically target customers who are less likely to return in the future. Identifying and addressing the needs and preferences of this group may involve a more personalized approach, extended engagement strategies, or innovative incentives to ensure their continued patronage, even after the campaign concludes.

```{r}
# Load necessary libraries
library(dplyr)
library(ggplot2)
library(tidyr)
library(plotly)

# Filter for 'offer received' and 'offer viewed' events
offer_data <- df_cust_offer %>%
  filter(event %in% c("offer received", "offer viewed")) %>%
  select(customer_id, event, days_elapsed, value_key, value_data) %>%
  arrange(customer_id, days_elapsed)

# Calculate time gap between 'offer received' and 'offer viewed'
offer_data <- offer_data %>%
  group_by(customer_id) %>%
  mutate(time_gap = lead(days_elapsed) - days_elapsed) %>%
  filter(event == "offer received")

# Filter out incomplete records (where offer viewed occurred before offer received)
offer_data <- offer_data %>%
  filter(!is.na(time_gap))

# Calculate the average time gap
average_time_gap <- mean(offer_data$time_gap)

# Print the average time gap
cat("Average time gap between receiving and viewing an offer:", round(average_time_gap, 2), "days\n")

# Perform additional analysis to understand the impact on conversion rates
conversion_data <- offer_data %>%
  group_by(time_gap) %>%
  summarize(conversions = sum(event == "offer viewed"))

# Create a monochromatic scatterplot with regression lines
plot <- ggplot(conversion_data, aes(x = time_gap, y = conversions)) +
  geom_point(color = "blue", size = 3) +
  geom_smooth(method = "lm", se = FALSE, color = "darkgreen") +
  labs(
    x = "Time Gap (days)",
    y = "Conversions",
    title = "Conversion Rate vs. Time Gap"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    panel.background = element_rect(fill = "darkgray")
  ) +
  scale_x_continuous(limits = c(1, max(conversion_data$time_gap)))  # Set x-axis limits

# Make the plot interactive using plotly
interactive_plot <- ggplotly(plot)

# Display the interactive plot
interactive_plot



```

**OBSERVATION:**

Average Time Between Receiving an Offer and Viewing It: The analysis of the data has shown that the average time between receiving a discount offer and viewing it is 1.98 days. This is the typical time it takes for customers to engage with the offer after receiving it.

Effect on Conversion Rates: Based on the scatter plot and the even scattering of points, it appears that the time gap between receiving an offer and viewing it does not have a significant impact on conversion rates. In other words, customers are equally likely to convert regardless of how quickly or slowly they view the offer after receiving it.

In summary, the data suggests that the time gap between receiving a discount offer and viewing it does not strongly influence conversion rates, as there is no apparent pattern or trend in the scatter plot.

## **EDA on Customer Data:**

### Q2. What is the profile of the customer base, including their gender distribution, age distribution, and income range, and how do these factors relate to each other?

#### Univariate Analysis - `age`

```{r}
# Create a side-by-side boxplot and histogram
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2))
boxplot(customers$age, xlab = "Age", main = "Boxplot", col = "lightblue")
hist(customers$age, xlab = "Age", main = "Histogram", col = "lightblue")

# Adjust axis label sizes
par(cex.lab = 1.5)

# Print descriptive statistics
summary(customers$age)
age_sd <- sd(customers$age)

# Print the standard deviation
cat("Standard Deviation of Age:", age_sd, "\n")
```

**Observations:**

-   The customer age range spans from 18 years as the youngest to 101 years as the oldest.

-   The distribution of customer ages appears to approximate a normal distribution, with a mean and standard deviation of approximately 54 and 17, respectively.

#### Univariate Analysis - `gender`

```{r}
library(ggplot2)
library(plotly)

# Create a data frame with the count of each gender category
gender_counts <- table(customers$gender)

# Calculate percentages
gender_percentages <- round((gender_counts / sum(gender_counts)) * 100, 1)

# Define custom colors
custom_colors <- c("#FF6F61", "#6B5B95", "#88B04B")  # You can use any color codes you like

# Create the 3D pie chart
pie_chart <- plot_ly(
  labels = names(gender_counts),
  values = gender_counts,
  type = "pie",
  textinfo = "label+percent",
  marker = list(colors = custom_colors),
  pull = c(0.1, 0.1, 0.2)  # Adjust pull for exploding wedges
) %>%
  layout(
    title = "Gender Distribution",
    scene = list(
      aspectmode = "cube",  # Center the chart
      camera = list(eye = list(x = 1.25, y = 1.25, z = 0.85))  # 3D view settings
    ),
    showlegend = FALSE
  )

# Display the 3D pie chart
pie_chart
```

**Observations:**

-   The customer base consists of a larger proportion of males (57.2%) compared to females (41.3%), with a minor representation (1.4%) from customers identifying with other genders.

```{r}
library(ggplot2)

# Calculate age group percentages
age_group_percentage <- round(prop.table(table(customers$age_group)) * 100, 1)

# Create the bar plot
ggplot(data = NULL, aes(x = names(age_group_percentage), y = age_group_percentage)) +
  geom_bar(stat = "identity", fill = "lightblue") +
  labs(x = "Age", y = "Percentage %", title = "Age Distribution") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12)) +
  geom_text(aes(label = paste0(age_group_percentage, "%")), position = position_stack(vjust = 0.5), size = 4) +
  scale_y_continuous(breaks = seq(0, 25, 5)) +
  coord_flip()
```

**Observations:** - The largest age group among customers is 56-65 years old, closely followed by the 46-55 years old group.

-   The third largest age group consists of customers aged 66-75 years.

-   Collectively, the top three age groups represent approximately 60% of the customer base.

-   This distribution is logical as individuals between 46 and 75 years of age tend to have more available time to visit cafes compared to younger age groups.

-   Additionally, they typically have better mobility than those above 75 years old, making them more likely to be cafe customers.

#### Univariate Analysis - `income`

```{r}
# Set up the layout with 1 row and 2 columns for the plots
par(mfrow = c(1, 2), mar = c(5, 4, 4, 2))

# Create a boxplot for income
boxplot(customers$income, xlab = "Income", main = "Boxplot", col = "lightblue")

# Create a histogram for income
hist(customers$income, xlab = "Income", main = "Histogram", col = "lightblue")

# Adjust label sizes
par(cex.lab = 1.5)

# Print descriptive statistics for income
summary(customers$income)

```

### Dividing customers into income groups

```{r}
# Create a new column `income_group`
customers$income_group <- cut(customers$income,
  breaks = c(min(customers$income), 45000, 60000, 75000, 90000, 105000, max(customers$income)),
  labels = c('30-45k', '45-60k', '60-75k', '75-90k', '90-105k', '> 105k')
)
```

```{r}
# Calculate income group percentages
income_group_percentage <- round(table(customers$income_group) / nrow(customers) * 100, 1)
```

```{r}
# Create a barplot
bp <- barplot(income_group_percentage, 
              main = "Income Group Distribution",
              xlab = "Income Group",
              ylab = "Percentage",
              col = "skyblue",
              names.arg = levels(customers$income_group),
              ylim = c(0, max(income_group_percentage) + 5)
)

# Add percentages within the bars
text(x = bp, y = income_group_percentage + 2, labels = paste(income_group_percentage, "%"), pos = 3)

# Add a legend
legend("topright", legend = paste(levels(customers$income_group), " (", income_group_percentage, "%)"), fill = "skyblue", bty = "n")
```

**Observations:**

-   Customer Income Range: The income of customers spans from 30k to 120k, with an average income of 65.4k.

-   Dominant Income Groups: The top two income groups are those earning 60-75k and 45-60k annually, collectively representing around 50% of the customer base.

-   Resemblance to Population: The income distribution among customers closely mirrors that of the general population. However, individuals with very low income might face challenges affording frequent visits to cafes, while those with extremely high income might opt for alternative coffee enjoyment methods.

#### Bivariate Analysis - `age` vs `gender`

```{r}
# Load the ggplot2 library
library(ggplot2)

# Create a 2D scatterplot with additional aesthetics
ggplot(customers, aes(x = gender, y = age, color = gender)) +
  geom_jitter(width = 0.3, alpha = 0.7, size = 1) +  # Adjust point size for a 3D effect
  labs(title = "Scatterplot of Age vs Gender", x = "Gender", y = "Age") +
  scale_color_manual(values = c("#E41A1C", "#377EB8", "#4DAF4A")) +  # Custom colors
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5), 
        panel.grid.major.y = element_line(color = "gray90"),
        axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better visibility
```

#### **Observations:**

-   Women are more likely to visit Starbucks than men. This is because there are more women in the 20-30 age range, which is the most common age range for Starbucks customers.

-   Men are more likely to visit Starbucks in their 40s and 50s, while women are more likely to visit Starbucks in their 30s and 40s.

-   There is a slight correlation between age and gender, with younger customers being more likely to be female and older customers being more likely to be male.

#### Bivariate Analysis - `income` vs `gender`

```{r}
# Calculate the mean income for females
mean_income_female <- mean(customers$income[customers$gender == "F"], na.rm = TRUE)

# Calculate the mean income for males
mean_income_male <- mean(customers$income[customers$gender == "M"], na.rm = TRUE)

mean_income_others <- mean(customers$income[customers$gender == "O"], na.rm = TRUE)
# Print the results
cat("Mean Income for Females: $", round(mean_income_female, 2), "\n")
cat("Mean Income for Males: $", round(mean_income_male, 2), "\n")
cat("Mean Income for Males: $", round(mean_income_others, 2), "\n")

```

```{r}
# Load the ggplot2 library
library(ggplot2)

# Create a scatterplot
ggplot(customers, aes(x = gender, y = income, color = gender)) +
  geom_jitter(width = 0.3, alpha = 0.7, size = 1) +
  labs(title = "Scatterplot of Income vs Gender", x = "Gender", y = "Income") +
  scale_color_manual(values = c("#E41A1C", "#377EB8", "#4DAF4A")) +  # Custom colors
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        panel.grid.major.y = element_line(color = "gray90"),
        axis.text.x = element_text(angle = 45, hjust = 1))

```

Observations:

-   Male customers have a right-skewed income distribution, indicating that a larger proportion of male customers falls within the lower half of the income spectrum among the company's customer base.

-   Male customers have a right-skewed income distribution, indicating that a larger proportion of male customers falls within the lower half of the income spectrum among the company's customer base.

-   Female customers have a significantly higher average income compared to customers of other genders. This disparity in income may be attributed to the assumption that female customers, on average, are older than customers in other gender groups.

-   On average, female customers have an income of \$71,000, while male customers have an average income of \$61,000. Customers of other genders have an average income of \$63,000.

### Bivariate Analysis - `income` vs `age`

```{r}
# Load required libraries
library(ggplot2)
library(dplyr)

# Create a summary dataframe
summary_data <- customers %>%
  group_by(age_group) %>%
  summarize(mean_income = mean(income))

# Create the barplot
ggplot(summary_data, aes(x = age_group, y = mean_income, fill = age_group)) +
  geom_bar(stat = "identity") +
  labs(x = "Age Group", y = "Income") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability
```

**Observations:**

-   Customers in the two younger age groups (18-35 years old) have an average annual income of approximately \$51,000 USD.

-   The middle age groups (36-55 years old) exhibit an average annual income of about \$65,000 USD.

-   All age groups above 56 years old display very similar average annual incomes, hovering around \$70,000 USD.

-   On average, older customers of the company tend to have higher incomes.

-   The company's customers across all age groups have substantially higher average incomes compared to the median income of US citizens in 2018, which stood at \$30,119 USD.

-   The use of the 2018 median income as a benchmark is justified because the dataset contains records only up to July 2018, and customer profile data, including income, is typically not frequently updated. Hence, it's more relevant to compare customer income with the population's income in the year they last became members.

#### `income` vs `gender` vs `age`

```{r}
# Load necessary libraries
library(plotly)
library(dplyr)

# Create a 3D scatterplot with Plotly
scatter_3d <- customers %>%
  plot_ly(x = ~age, y = ~income, z = ~gender, color = ~gender, colors = c("#E41A1C", "#377EB8", "#4DAF4A"),
          type = "scatter3d", mode = "markers",
          marker = list(size = 2)) %>%
  layout(scene = list(xaxis = list(title = "Age"),
                     yaxis = list(title = "Income"),
                     zaxis = list(title = "Gender")))

# Show the 3D scatterplot
scatter_3d
```

**Observation:**

-   Income tends to increase with age for both men and women. This is evident from the fact that the scatterplot shows a general upward trend from left to right.

-   Another interesting thing we can observe is that female customers with higher incomes, on average, are older than customers in other gender groups.

**Answer to SMART question based on the above analysis**

The customer base consists of a larger proportion of males (57.2%) compared to females (41.3%), with a minor representation (1.4%) from customers identifying with other genders. The customer age range spans from 18 years as the youngest to 101 years as the oldest. The income of customers spans from 30k to 120k, with an average income of 65.4k. The income distribution closely mirrors that of the general population. There is a logical relationship between age and cafe visits, as individuals between 46 and 75 years tend to have more available time to visit cafes. The income distribution varies between genders, with females having higher average incomes

#### How has the customer base evolved over time, both in terms of new member sign-ups and member growth, and are there any notable trends or changes?

#### Univariate Analysis - `became_member_on`

```{r}
library(dplyr)
library(lubridate)

# Create a new data frame df_member
df_member <- customers %>%
  select(id, became_member_on)

# Add columns `year`, `month`, `day_of_week`
df_member <- df_member %>%
  mutate(
    year = year(became_member_on),
    month = month(became_member_on),
    day = day(became_member_on),
    month_name = month(became_member_on, label = TRUE),
    day_of_week = wday(became_member_on, label = TRUE),
    day_name = wday(became_member_on, label = TRUE, abbr = FALSE)
  )

head(df_member, 3)
```

```{r}
# Load the ggplot2 library if not already loaded
library(ggplot2)

# Create a count plot with detailed customization and values
ggplot(data = df_member, aes(x = year, fill = factor(year))) +
  geom_bar(color = "black", width = 0.7, position = "dodge") +
  geom_text(aes(label = after_stat(count)), stat = "count", vjust = -0.5, size = 4, color = "black") +
  scale_fill_brewer(palette = "Set1") +  # Use a predefined color palette
  labs(title = "Number of New Members by Year", x = "Year", y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(size = 12, angle = 45, hjust = 1),
        axis.text.y = element_text(size = 12),
        axis.title.x = element_text(size = 14),
        axis.title.y = element_text(size = 14
        )
  )

```

### Daily member growth:

```{r}
# Load the required libraries if not already loaded
library(dplyr)
library(tidyr)

# Create a time series with the number of new members on each day
df_member_growth <- df_member %>%
  count(became_member_on) %>%
  arrange(became_member_on) %>%
  rename(`Number of New Members` = n)

```

```{r}
# Assuming df_member_growth is already defined
# Create four phases with different daily growth

# Phase 1: '2013-july' to '2015-july'
phase_1 <- df_member_growth %>%
  filter(became_member_on >= as.Date('2013-07-01') & became_member_on <= as.Date('2015-07-31'))

len_phase_1 <- nrow(phase_1)
mean_phase_1 <- mean(phase_1$`Number of New Members`)

# Phase 2: '2015-august' to '2017-july'
phase_2 <- df_member_growth %>%
  filter(became_member_on >= as.Date('2015-08-01') & became_member_on <= as.Date('2017-07-31'))

len_phase_2 <- nrow(phase_2)
mean_phase_2 <- mean(phase_2$`Number of New Members`)

# Phase 3: '2017-august' to '2018-jan'
phase_3 <- df_member_growth %>%
  filter(became_member_on >= as.Date('2017-08-01') & became_member_on <= as.Date('2018-01-31'))

len_phase_3 <- nrow(phase_3)
mean_phase_3 <- mean(phase_3$`Number of New Members`)

# Phase 4: '2018-feb' to '2018-july'
phase_4 <- df_member_growth %>%
  filter(became_member_on >= as.Date('2018-02-01') & became_member_on <= as.Date('2018-07-31'))

len_phase_4 <- nrow(phase_4)
mean_phase_4 <- mean(phase_4$`Number of New Members`)

```

```{r}
# Load the ggplot2 library if not already loaded
library(ggplot2)

# Define the means and lengths for each phase
mean_phases <- c(mean_phase_1, mean_phase_2, mean_phase_3, mean_phase_4)
len_phases <- c(len_phase_1, len_phase_2, len_phase_3, len_phase_4)

# Create a data frame with phase information
phase_info <- data.frame(
  phase = c("Phase 1", "Phase 2", "Phase 3", "Phase 4"),
  start_date = as.Date(c('2013-07-01', '2015-08-01', '2017-08-01', '2018-02-01')),
  end_date = as.Date(c('2015-07-31', '2017-07-31', '2018-01-31', '2018-07-31')),
  mean = mean_phases
)

# Create the plot with phases and mean values
ggplot(data = df_member_growth) +
  geom_line(aes(x = became_member_on, y = `Number of New Members`)) +
  geom_hline(data = phase_info, aes(yintercept = mean), linetype = "dashed", color = "red", size = 1) +
  geom_vline(data = phase_info, aes(xintercept = start_date), linetype = "dotted", color = "blue", size = 1) +
  geom_vline(data = phase_info, aes(xintercept = end_date), linetype = "dotted", color = "blue", size = 1) +
  labs(
    x = "Date",
    y = "Number of New Members",
    title = "Daily Member Growth",
    subtitle = "Phase-wise",
    caption = "Red dashed lines represent mean values for each phase"
  ) +
  scale_x_date(date_labels = "%Y-%b", date_breaks = "3 months") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 20, face = "bold"),
    axis.title = element_text(size = 16),
    axis.text.x = element_text(size = 14, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 14),
    legend.position = "none"  # Hide the legend
  )

```

**Observations:**

-   The dataset includes customers who became members between July 2013 and July 2018.

-   Only a small percentage of customers (approximately 2.2%) chose to become members from 2013 to the middle of 2015.

-   The number of new members started to increase significantly from the middle of 2015 and experienced a substantial growth spike from the middle of 2017. This suggests that the company likely executed successful campaigns during these periods, resulting in a significant boost in member growth.

-   However, in early 2018, there was a noticeable decline in daily member growth, with a 31% decrease (from 24.4 to 16.8). This drop may indicate that new strategies implemented during that time had a negative impact on member growth.

### Member growth by Month:

```{r}
# Load the ggplot2 library if not already loaded
library(ggplot2)

# Create a detailed and rainbow-colored count plot
ggplot(data = df_member, aes(x = month_name)) +
  geom_bar(fill = rainbow(length(unique(df_member$month_name)), s = 0.7, v = 0.8), color = "black", width = 0.7) +
  labs(
    title = "Number of New Members by Month",
    x = "Count",
    y = "Month"
  ) +
  scale_fill_identity() +
  theme_minimal() +
  theme(
    axis.text.x = element_text(size = 12, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 12),
    axis.title.x = element_text(size = 14)
  )

```

### Member growth by weekday:

```{r}
# Load the ggplot2 library if not already loaded
library(ggplot2)

# Create a custom color palette
my_colors <- c("#3498db", "#e74c3c", "#2ecc71", "#f1c40f", "#9b59b6", "#e67e22", "#1abc9c")

# Create a detailed and appealing count plot by weekday
ggplot(data = df_member, aes(x = factor(day_name, levels = c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"))) ) +
  geom_bar(fill = my_colors, color = "black", width = 0.7) +
  labs(
    title = "Number of New Members by Weekday",
    x = "Count",
    y = "Weekday"
  ) +
  scale_x_discrete(labels = c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday")) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(size = 12, angle = 45, hjust = 1),
    axis.text.y = element_text(size = 12),
    axis.title.x = element_text(size = 14)
  )

```

**Observations:**

-   August, October, and December experienced the highest influx of new members, with August leading the way.

-   Conversely, February had the lowest average number of new members, indicating a drop in membership during this month.

-   Weekends, unsurprisingly, had higher member growth compared to weekdays. Among weekdays, Tuesday showed the highest member growth.

-   On average, Friday had the fewest new members, making it the day with the lowest member sign-ups.

**Answer to SMART question based on the above analysis:**

The dataset includes customers who became members between July 2013 and July 2018. Daily member growth increased significantly from the middle of 2015, with a substantial spike in growth from the middle of 2017, suggesting successful campaigns during these periods. However, there was a noticeable decline in early 2018, indicating that new strategies implemented at that time may have had a negative impact on member growth. August, October, and December experienced the highest influx of new members, with weekends and Tuesdays showing higher member growth. The data indicates fluctuations in member growth over time.

## **EDA for Portfolio**

```{r}
library(ggplot2)
library(dplyr)

# Count the occurrences of each channel
channel_counts <- df_offers %>%
  group_by(channels) %>%
  summarise(count = n())

ggplot(channel_counts, aes(x = channels, y = count)) +
  geom_bar(stat = "identity", fill = "#618264", color = "black", size = 0.2) +
  labs(x = "Channels", y = "Count", title = "Promotional Channels") +
  theme_minimal() 
```

**Observations:** Customers received offers via a combination of four different promotion channels: social media, email, mobile apps, and websites. The 10 offers use 4 different combinations of channels. Comparisons between offers using various channels can be used to determine the promotional impact of each channel. And from the above plot, it is clearly visible that combination of all the four channels leads.

```{r}
colors <- c("#EFF6EE", "#273043", "#9197AE","darkgray")
pie(channel_counts$count, labels = channel_counts$channels, main='Distribution of Number of Channels per Offer', col=colors)
legend("bottomleft", legend=channel_counts$count, fill=colors, title="Occurance of Channels")
```

**Observations:** The above observation shows that the combination of 3 channels had the maximum count per offer.

```{r}
#Offers based on difficulty and channels through which they are offered

custom_colors <- c("#BF8B67", "#632626", "#9D5353", "#D0B8A8")

ggplot(df_offers, aes(x = as.factor(difficulty), fill = channels)) +
  geom_bar(position = 'stack', color = 'black', size = 0.5) +
  scale_fill_manual(values = custom_colors) +  # Use custom colors
  labs(y = 'Number of Offers', x = 'Difficulty of Offers', 
       title = 'Offers based on difficulty and channels through which they are offered') +
  theme_minimal() +  
  theme(legend.position = "bottom")
```

**Observations:** Difficulty refers to the minimum amount required to spend to avail an offer and the min amount requires starts from 0 till 20. The offer which came through two combination of channels had the highest amount to be spent to avail an offer with combination of 3 channels being the least.

## **EDA on transcript and portfolio combined**

### Q3. What are the most popular offers and the influential factors driving the View rates of the Offers?

```{r}
df_offers
head(df_cust_offer)
```

```{r}
library(dplyr)

# Create a dataframe that only contains events about offers
df_event <- df_cust_offer %>% filter(event != "transaction")

# Merge df_event with df_offers
event_offer <- df_event %>% 
  left_join(df_offers, by = c("value_data" = "id")) %>%
  select(
    customer_id, event, offer_alias, reward, channels, difficulty,
    duration, offer_type, days_elapsed
  )

head(event_offer)

#event_offer <- event_offer %>% select(-value_data)
```

```{r}
# Filter the events for 'offer received' and 'offer completed'
offer_received <- event_offer[event_offer$event == 'offer received', ]
offer_completed <- event_offer[event_offer$event == 'offer completed', ]

# Count the number of times each offer is received and completed
p0 <- table(offer_received$offer_alias)
p2 <- table(offer_completed$offer_alias)
combined_names <- intersect(names(p0), names(p2))
p0 <- p0[combined_names]
p2 <- p2[combined_names]

# Calculate the overall completion rate
overall_complete_rate <- (p2 / p0)*100

# Sort the overall completion rate in descending order
overall_complete_rate <- overall_complete_rate[order(overall_complete_rate*100, decreasing = TRUE)]

print(overall_complete_rate)
```

```{r}
library(ggplot2)

completion_data <- data.frame(
  Offer = names(overall_complete_rate),
  CompletionRate <- overall_complete_rate
)

completion_data <- completion_data %>% arrange(desc(CompletionRate))

# Create the bar plot
ggplot(completion_data, aes(x = Offer, y = CompletionRate)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  theme_minimal() +
  labs(
    x = "Offer",
    y = "Percentage",
    title = "Overall Completion Rate %",
    ylim(0, 1.2),
    y.axis.text = c('0%', '20%', '40%', '60%', '80%', '100%')
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)+
            geom_text(aes(label = scales::percent(CompletionRate, scale = 100)), vjust = -0.5, size = 4)+
          scale_y_continuous(labels = scales::percent_format(scale = 1), breaks = seq(0, 1, by = 0.2)) ) # Format y-axis as percentage

```

Note: Offers I and J are excluded from the plot because they are informational offers and, as a result, they do not have any 'offer completed' events associated with them.

Observations: 1. With remarkable completion rates of 70%, 67.4%, and 56.7%, respectively, are Offer F, Offer E, and Offer B. These incentives worked quite well to motivate clients to do the related duties. 2. Offer D, on the other hand, had the lowest completion rate of approximately 44%. This implies that, in comparison to the best offers, this one could not have been as enticing or successful in drawing in clients.

```{r}
# Filter the event_offer data frame for 'offer received' events
offer_received <- event_offer[event_offer$event == 'offer received', ]
p0 <- table(offer_received$offer_alias)
```

```{r}
# Create a data frame for visualization
offer_received_data <- data.frame(
  Offer = names(p0),
  Count = as.numeric(p0)
)

bar_color <- "#D68060"

# Create the bar plot 
barplot(p0, 
        names.arg = names(p0), 
        col = bar_color, 
        border = "black",  # Add a black border
        xlab = 'Offers', 
        ylab = 'Count of Offers',
        main = 'Offer Received',
        cex.main = 1.8, 
        cex.lab = 1.5, 
        cex.axis = 1.2)

```

Observation: Each of the ten offers received a similar number of times, with approximately 7,600 receptions for each offer. The distribution of offer receptions was consistent, indicating that there was no significant discrepancy in how often different offers were received by customers.

```{r}
# Number of offers
num_offers <- nrow(df_offers)

# Create an empty data frame to store the counts
each_offer_received <- data.frame(matrix(ncol = num_offers))
colnames(each_offer_received) <- LETTERS[1:num_offers]

# Loop through the offers and count how many times each offer was received on each day
for (i in 1:num_offers) {
  offer_alias <- LETTERS[i]
  offer_received_counts <- table(df_event[df_event$offer_alias == offer_alias, "days_since_start"])
  each_offer_received[, i] <- offer_received_counts
}

# Set row names explicitly
row_names <- paste0('Day', unique(df_event$days_since_start))
rownames(each_offer_received) <- row_names
```

```{r}
offer_completed <- event_offer[event_offer$event == 'offer completed', ]

# Create a table of the completion rate
p2 <- table(offer_completed$offer_alias)
p2 <- sort(p2, decreasing = TRUE)

# Subset the data for 'offer viewed' events
offer_viewed <- event_offer[event_offer$event == "offer viewed", ]

# Count the number of times each offer was viewed
p1 <- table(offer_viewed$offer_alias)
p1 <- sort(p1, decreasing = TRUE)

# Calculate the view rate for each offer
p1_rate <- p1 / p0

# Sort the view rates in descending order
p1_rate <- p1_rate[order(p1_rate, decreasing = TRUE)]

# Create a bar plot
barplot(p1_rate, col = c('#011f4b', '#011f4b', '#011f4b', '#011f4b', '#03396c', '#03396c', '#005b96', '#005b96', '#005b96', '#b3cde0'),
        names.arg = names(p1_rate), 
        main = 'View Rate Percentage',
        xlab = 'Offers',
        ylab = 'Percentage',
        ylim = c(0, 1.2),
        yaxt = 'n')
axis(2, at = seq(0, 1.2, 0.2), labels = paste0(seq(0, 1.2, 0.2) * 100, '%'))

```

**Observations:** The results are quite intriguing. When we look at the bar plot with 10 bars, each representing a different offer, we can see that these bars can be grouped into four distinct levels of height. These four levels correspond to four specific combinations of promotion channels. This alignment is also reflected in the colors used in the plot to represent each offer.

Group-1: (F D E B) email, mobile, social, web Group-2: (J C) email, mobile, social Group-3: (I A G) email, mobile, web Group-4: (H) email, web

Conclusions:

The study draws attention to how different promotion channels differ in their efficacy: 1. Web-based offers (Group 1) have a little greater view rate than Group 2, but their overall contribution is minimal when compared to Group 2. 2. Group 2, which consists of advertisements on social media, is notable for having a much greater view rate. Offers from social media platforms significantly affect the view rate. 3. Group 3, which features promotions for mobile apps, likewise does well and has a higher view rate. 4. Group 4, which is dominated by email and has a little web component, lessens the impact of web-based offers. Email promotions have a significant and marginally better influence on view rates than mobile promotions, as evidenced by the fact that the majority of offers in Group 4 are viewed via email.

To sum up, the offer view rate was influenced by all promotion channels, however their relative importance differed. In terms of relevance, social media was the most influential, followed by websites, email, smartphones, and so on.

```{r}
# Filter the dataframe for completed offers
offer_completed <- event_offer[event_offer$event == "offer completed", ]

# Create a table of the completion count for each offer
p2 <- table(offer_completed$offer_alias)

# Sort the table in descending order
p2 <- sort(p2, decreasing = TRUE)

# Ensure p1 and p2 have the same dimensions
common_names <- intersect(names(p1), names(p2))
p1 <- p1[common_names]
p2 <- p2[common_names]

# Calculate completion rate based on offers viewed
p2_rate <- (p2 / p1)*100
```

```{r}
# Calculate completion rate based on offers viewed
p2_rate <- (p2[common_names] / p1[common_names]) * 100

# Define colors for the bars
color_list <- c("#d0ada7", "#d0ada7", "#ad6a6c", "#ad6a6c", "#ad6a6c", "#ad6a6c", "#d0ada7", "#d0ada7")
color_list1 <- c("#d0ada7", "#ad6a6c")
# Create a horizontal bar plot using the barplot function with horiz = TRUE
barplot(p2_rate, horiz = TRUE, col = color_list, 
        main = 'Completion Rate %(based on views)',
        ylab = 'Offer',
        xlab = 'Percentage',
        xlim = c(0, 140))

abline(v = 100, col = "black", lty = 2)

# Create a legend
legend("bottomright", 
       legend = c("Discount", "BOGO"), 
       fill = color_list1)
```

**Note:** Darker shades represent BOGO (Buy One, Get One) offers, while lighter shades represent discount offers.

Observations: 1. The completion rates of offers that have been viewed range from 46% to an astounding 128%. Interestingly, Offers H and A had completion rates exceeding 100%, meaning that clients completed these offers multiple times on average. 2. With the exception of Offer A, the top five offers with the greatest completion rates are all of the "discount" offer type. This shows that discounts were typically preferred by consumers over buy one, get one (BOGO) deals. From this it can be concluded that, the main factor influencing offer completion rate is the offer type, 'Discount' \> 'bogo'.

Conclusion: It's important to remember that strong completion rates do not always translate into high view rates for an offer. In actuality, there was an almost inverse correlation between completion and view rates.

```{r}
# Load necessary libraries if not already loaded
library(dplyr)

# Create a new data frame to hold relevant variables
offers_added <- df_offers %>%
  mutate(view_rate = p1_rate[match(offer_alias, names(p1_rate))],
         complete_rate = p2_rate[match(offer_alias, names(p2_rate))]) 

# Set `offer_alias` as the index
rownames(offers_added) <- offers_added$offer_alias
offers_added$offer_alias <- NULL

# Extract numeric columns
offers_numeric <- offers_added %>% select_if(is.numeric)
head(offers_numeric)
```

```{r}
# Load the corrplot library
library(corrplot)

# Compute the correlation matrix for the entire dataset
correlation_matrix_view <- cor(offers_numeric[, -ncol(offers_numeric)])
correlation_matrix_complete <- cor(offers_numeric[, c(1, 2, 3, 5)])  # Select relevant columns

# Set up the layout for two side-by-side plots
par(mfrow = c(1, 2))

# Create the correlation plot for View Rate %
corrplot(correlation_matrix_view, method = "color", col = colorRampPalette(c("#900C3F", "#FF5733", "#FFC300"))(100), tl.cex = 0.7, title = "Correlation - View Rate %")

# Create the correlation plot for Complete Rate %
#corrplot(correlation_matrix_complete, method = "color", col = colorRampPalette(c("#900C3F", "#FF5733", "#FFC300"))(100), tl.cex = 0.7, title = "Correlation - Complete Rate %")

# Reset the layout to its default value
par(mfrow = c(1, 1))
```

Observations: 1. View rate is positively correlated with reward and negatively correlated with difficulty. 2. The three numerical factors---difficulty, time, and rewards---all showed no significant correlations with the view rate.

**Answer to SMART question based on the above analysis:**

1.  Popular Offers: Customers chose Offers F, E, and B as the most popular, with completion rates of 70%, 67.4%, and 56.7%, respectively. 2. Influential Factors: The choice of promotional channel had the most impact on view rates, with Social Media proving to be the most effective, followed by Email and Mobile, while the Company Website lagged behind. Which is "Social Media \> Email \>= Mobile \> Company Website" Furthermore, the type of offer was important, with 'discount' offers generating higher customer engagement than 'BOGO' promos. 3. Key Takeaways: Understanding the importance of promotional channels and offer kinds is critical for increasing view rates. Businesses can improve their promotional strategy and increase client involvement by leveraging effective channels such as Social Media and focusing on 'discount' offers.

## **EDA for merged dataset**

### Q4. Which age groups are more likely to accept offers than others? Do these preferences also differ based on gender?

```{r}
#Distribution of Number of Channels per Offer
channels_count <- sapply(df_offers$channels, function(x) length(unlist(strsplit(x, ','))))
barplot(table(channels_count), main='Distribution of Number of Channels per Offer', col='#EF9595', xlab='Number of Channels', ylab='Count')
```

**Observations:** The above observation shows that the combination of 3 channels had the maximum count per offer.

```{r}
colors <- c("#ad6a6c", "#d0ada7", "#e8d6cb")

# Count the frequency of each offer type
offer_counts <- table(final$offer_type)

ggplot(data = as.data.frame(offer_counts), aes(x = Var1, y = Freq)) +
  geom_bar(stat = "identity", fill = colors, color = "black") +
  labs(title = "Frequency of Each Offer Type",
       x = "Offer Type",
       y = "Count") +
  scale_fill_manual(values = colors)
```

**Observations:** From the above observation BOGO and the discount offer type has the maximum count of nearly 66,000 and 62,000 respectively while the informational offer had the least count.

```{r}
# Summarize the data to get counts
counts <- final %>%
  group_by(offer_type, event) %>%
  summarize(count = n())
colors <- c("#34BE82", "#FF7F3F", "#1746A2")

ggplot(counts, aes(x = offer_type, y = count, fill = event)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Event Counts for Each Offer Type",
       x = "Offer Type",
       y = "Count") +
  scale_fill_manual(values = colors)  
```

**Observations:**

1)  BOGO offer appears to be especially successful in views and decent with the completions, indicating a strong level of customer interest.
2)  On the other hand discount offer does attract better customers but slightly less than BOGO.
3)  However informational offers did not result in any completion of the offer and also had only a notable views and receiving which is much less compared to both BOGO and discount. To conclude, based on the completions, discount offer had an upper hand as it attracted many customers.

```{r}
# Offer Preferences by Age Group
age_offer_counts <- final %>%
  group_by(age_group, offer_type) %>%
  summarize(count = n()) 

colors <- c("#ad6a6c", "#d0ada7", "#e8d6cb")
ggplot(age_offer_counts, aes(x = age_group, y = count, fill = offer_type)) +
  geom_bar(stat = 'identity', position = 'dodge') +
  labs(title = 'Offer Type Preferences by Age Group',
       x = 'Age Group',
       y = 'Count') +
  theme_minimal() +
    theme(axis.text.x = element_text(angle = 50, vjust = 1, hjust = 1)) +
    scale_fill_manual(values = colors)  
```

**Observations:** THis plot represent the distribution of offers (BOGO, discount, and informational) across different age groups. It is clearly visible that BOGO offers is the highest across all age groups, then the discounts and informational stands at the last. This plot gives an overview of how the offers are being distributed among various age groups.

```{r}
#Offer Type Preferences by Gender
offer_counts <- table(final$gender, final$offer_type)
offer_counts_df <- as.data.frame(offer_counts)
colnames(offer_counts_df) <- c('gender', 'offer_type', 'count')  
colors <- c("#ad6a6c", "#d0ada7", "#e8d6cb")

ggplot(offer_counts_df, aes(x = gender, y = count, fill = offer_type)) +
  geom_bar(stat = 'identity', position = 'dodge') +
  labs(title = 'Offer Type Preferences by Gender',
       x = 'Gender',
       y = 'Count') +
  theme_minimal() +scale_fill_manual(values = colors)
```

**Observations:** This indicates the engagement patterns with different offer types such as BOGO, Discount, and Informational offers for different gender categories(Female,male, other) 1) Men show more engagement than women and other gender categories in all the three offer types(BOGO, discount, informational). 2) Women show a huge count of involvement, but are slightly behind men with no much difference. 3) Other gender categories are nearly ignorable when compared to men and women.

```{r}
# Filter data for each gender
final_male <- final %>% filter(gender == "M")
final_female <- final %>% filter(gender == "F")
final_other <- final %>% filter(gender == "O")
colors <- c("#34BE82", "#FF7F3F", "#1746A2")

ggplot(final, aes(x = age_group, fill = event)) +
  geom_bar(position = 'dodge') +
  labs(title = 'Offer event type by Age Group irrespective of gender',
       x = 'Age Group',
       y = 'Count',
       fill = 'Event Type') +
  theme_minimal() +  scale_fill_manual(values = colors)+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))

#MALE
ggplot(final_male, aes(x = age_group, fill = event)) +
  geom_bar(position = 'dodge') +
  labs(title = 'Offer event type by Age Group - Male',
       x = 'Age Group',
       y = 'Count',
       fill = 'Event Type') +
  theme_minimal() +  scale_fill_manual(values = colors)+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))

#FEMALE
ggplot(final_female, aes(x = age_group, fill = event)) +
  geom_bar(position = 'dodge') +
  labs(title = 'Offer event type by Age Group - Female',
       x = 'Age Group',
       y = 'Count',
       fill = 'Event Type') +
  theme_minimal() +scale_fill_manual(values = colors)+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))

#OTHERS
ggplot(final_other, aes(x = age_group, fill = event)) +
  geom_bar(position = 'dodge') +
  labs(title = 'Offer event type by Age Group - Other',
       x = 'Age Group',
       y = 'Count',
       fill = 'Event Type') +
  theme_minimal() +scale_fill_manual(values = colors)+
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
```

**Observations:** Across all age groups and gender, the most frequent event type is offer received, followed by offer viewed and offer completed. Both the male and female in the age group of 56-65 years have completed the most offers whereas the others in the range of 46-55years have completed the most offers.

# **Hypothesis Testing**

```{r}
contingency_table <- table(final$gender, final$age_group)
chi_squared_result <- chisq.test(contingency_table)
print(chi_squared_result)
```

**Null Hypothesis (H0):** There is no association or relationship between the two categorical variables, "gender" and "age_group" In other words, they are independent of each other.

**Alternative Hypothesis (H1):** There is an association or relationship between the two categorical variables, "gender" and "age_group" They are not independent of each other.

**P-Value:** The p-value associated with the test statistic is less than 2.2e-16, which is essentially zero. Given the extremely low p-value (essentially zero), we can conclude that there is a significant association or relationship between the two categorical variables tested in the chi-squared test (likely "gender" and "age_group"). In other words, we reject the null hypothesis (H0) that there is no association between these variables. Therefore, there is strong evidence to suggest that "gender" and "age_group" are not independent of each other, and there is a significant relationship between them.

**Answer to SMART question based on the above analysis:**

According to the analysis we made,BOGO is the most preferred offer across all age groups, with the age group of 56-65 having the highest offer completion rates, then age group of 46-55.When compared to the women and other gender categories, men are more engaged for all offer types while Women are slightly less than men and other gender are almost negligible. Overall, the age group 56-65 appears to be more likely to accept offers, and while gender differences in engagement exist, preferences for offer types are generally consistent across demographics, with BOGO being the most popular.
